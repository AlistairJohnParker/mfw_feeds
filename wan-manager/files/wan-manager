#!/bin/sh

. /lib/functions/network.sh
. /usr/share/libubox/jshn.sh

DEBUG=false

# logMessage is used to log a normal stdout message to the logger
# @param $1 - the message to log
logMessage() 
{
	if [ "$DEBUG" = true ] ; then
		logger -t wan-manager "$1"
	fi
}

# check_for_table checks for nft tables to exist
# $1 - ip version type
# $2 - table name to check for
check_for_table()
{
	ipCheck=$1
	tableCheck=$2
	output=`nft list table $ipCheck $tableCheck`
	retval=$?
	if [ $retval -ne 0 ]; then
		echo "NFT does not have a required table for wan-manager"
		exit 1
	fi
}

# handle_term is used to handle the sigterm signal
handle_term()
{
	for i in `pgrep -P $$ `
	do
		kill -9 $i
	done
}

# wait_for_change will use inotify to wait for specific files to change
# $1 - the files to wait for
wait_for_change()
{
	files=$1

	inotifywait -r -qq -e create,modify $files
}

# is_offline is used to determine the interface stats offline status
# $1 - the interface ID
# $2 - the interface family to check
is_offline()
{                                                                                                                                                                                      
		local offline

		id=$1
		family=$2
		json_load_file /tmp/stats.json
		if json_is_a interfaces array ; then
				json_select interfaces
				json_get_keys interfaces
				for intf in $interfaces; do
						json_select $intf
						json_get_var interfaceId interfaceId
						if [ $id = $interfaceId ] ; then
								logMessage "is_offline: getting offline status for $id and family: $family"
								if [ $family = "ipv6" ] ; then
									json_get_var offline6 offline
								else
									json_get_var offline offline
								fi
						fi
						json_select ..
				done
				json_select ..
		fi

		logMessage "is_offline: offline status for $id family: $family is $offline"

		echo $offline
}

# get_wan_bandwidth is used to gather the QOS bandwidth from settings
# $1 - the interface id
get_wan_bandwidth()
{
	id=$1

	ret=0

	json_load_file /etc/config/current.json
	json_select network
	json_select interfaces
	json_get_keys interfaces
	for i in $interfaces ; do
		json_select $i
		json_get_var interfaceId interfaceId
		if [ $id = $interfaceId ] ; then
			json_get_var downloadKbps downloadKbps
			ret=$downloadKbps
		fi
		json_select ..
	done
	json_select ..
	json_select ..

	echo $ret
}

# get_static_weight is used to get the WAN weight from the settings file, per policy
# $1 - policy name
# $2 - interface id
get_static_weight()
{
	policy=$1
	id=$2

	ret=0

	json_load_file /etc/config/current.json
	json_select wan
	json_select policies
	json_get_keys policies
	for p in $policies ; do
		json_select $p
		json_get_var policyId policyId
		policyIdString="policy-$policyId"
		if [ $policy = $policyIdString ] ; then
			json_select interfaces
			json_get_keys interfaces
			for i in $interfaces ; do
				json_select $i
				json_get_var interfaceId interfaceId
				if [ $interfaceId -eq 0 ] ; then
					ret=1
				elif [ $id = $interfaceId ] ; then
					json_get_var weight weight
					ret=$weight
				fi
				json_select ..
			done
			json_select ..
		fi
		json_select ..
	done
	json_select ..
	json_select ..

	echo $ret
}

# get_stat is used to retrieve specific stats from the /tmp/stats.json file, per interface id
# $1 - interface id
# $2 - the stat name to look for (ie: ping, latency, etc.)
# $3 - the metric name to look for (ie: 1_minute, 10_minute, etc.)
get_stat()
{
	id=$1
	stat_name=$2
	metric_name=$3

	test=0

	json_load_file /tmp/stats.json
	if json_is_a interfaces array ; then
		json_select interfaces
		json_get_keys interfaces
		for intf in $interfaces; do
			json_select $intf
			json_get_var interfaceId interfaceId
			if [ $id = $interfaceId ] ; then
				json_select "stats"
				json_get_keys stats
				for stat in $stats; do
					json_select $stat
					json_get_vars name
					if [ $stat_name = $name ] ; then
						json_select "metrics"
						json_get_keys metrics
						for metric in $metrics; do
							json_select $metric
							json_get_vars name value
							if [ $metric_name = $name ] ; then
								test=$(echo ${value%%.*})
							fi
							json_select ..
						done
						json_select ..
					fi
					json_select ..
				done
				json_select ..
			fi
			json_select ..
		done
		json_select ..
	fi

	echo $test
}

# wan_is_up searches through the policy directory
# to find out if specific WANs are currently down
# $1 - the policy to use
# $2 - the interface ID
# $3 - the IP family type
wan_is_up()
{
	policy=$1
	id=$2
	family=$3

	test_dir="/tmp/wan_status/$policy/wan-$id"

	! find $test_dir -type f -iname $family | xargs grep down > /dev/null
}

# disable_policy is used to disable specific policies when a wan is down
# $1 - policy to disable
# $2 - the WANs involved
disable_policy()
{
	policy=$1
	wans=$2

	TMPFILE=`mktemp -t $policy-changeset.XXXXXX`

	for wan in $wans ; do
		echo flush set ip wan-routing wan-$wan-table >> $TMPFILE
		echo flush set ip6 wan-routing wan-$wan-table >> $TMPFILE
	done

	echo flush chain ip wan-routing route-to-$policy >> $TMPFILE
	echo flush set ip wan-routing $policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy return comment \"policy disabled\" >> $TMPFILE

	echo flush chain ip6 wan-routing route-to-$policy >> $TMPFILE
	echo flush set ip6 wan-routing $policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy return comment \"policy disabled\" >> $TMPFILE

	nft -f $TMPFILE
	retval=$?
	logMessage "disabling policy: $policy All Wans:$wans Retval: $retval"
	while [ $retval -ne 0 ] ; do
		nft -f $TMPFILE
		retval=$?
		logMessage "nft -f Failed to disable policy: $policy All Wans:$wans Retval: $retval, trying again..."
	done
	rm $TMPFILE
}

# determinePolicyWans is used to determine which wans and policy wans are available based on 
# wans associated with the policy directories, and all wans
# $1 - the policy directory
# $2 - wans
# $3 - policy related wans
# $4 - caller type, for logging
determinePolicyWans() 
{
	policy_dir=$1
	wans=$2
	policy_wans=$3

	for d in $policy_dir/* ; do
		logMessage "determinePolicyWans: found file: $d"
		fileName=$(echo ${d##*/})

		# Ignore the status files in the policy directory
		if [ $fileName == "status" ] ; then
			logMessage "determinePolicyWans: skipping file: $d"
			continue
		fi

		# $(d##*/) is extracting the last directory in the string path cut on 2nd field to get the numerical wan ID
		# ex:
		# assume d = /tmp/wan_status/policy-822f5c96-e04b-4248-aea4-7cbd5d4a8af5/wan-2
		# then id = 2
		id=$(echo $fileName | cut -d '-' -f 2)	
		policy_wans="$wans $id"
		if wan_is_up $policy $id "ipv4"; then
			wans="$wans $id"
		fi
	done

	logMessage "determinePolicyWans: policy_wans: $policy_wans wans: $wans"
}

# jump_policy is used to insert jump rules for specific policies
# $1 - policy associated with the chain
# $2 - the interface id of the wan to use
# $3 - the wans included in this policy
jump_policy()
{
	policy=$1
	id=$2
	wans=$3

	TMPFILE=`mktemp -t $policy-changeset.XXXXXX`

	for wan in $wans ; do
		echo flush set ip wan-routing wan-$wan-table >> $TMPFILE
		echo flush set ip6 wan-routing wan-$wan-table >> $TMPFILE
	done

	echo flush chain ip wan-routing route-to-$policy >> $TMPFILE
	echo flush set ip wan-routing $policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy set update ip saddr . ip daddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy set update ip daddr . ip saddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy jump update-rule-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy dict sessions ct id wan_policy long_string set $policy >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy jump mark-for-wan-$id >> $TMPFILE

	echo flush chain ip6 wan-routing route-to-$policy >> $TMPFILE
	echo flush set ip6 wan-routing $policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy set update ip6 saddr . ip6 daddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy set update ip6 daddr . ip6 saddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy jump update-rule-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy dict sessions ct id wan_policy long_string set $policy >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy jump mark-for-wan-$id >> $TMPFILE

	nft -f $TMPFILE
	retval=$?
	logMessage "updating jump_policy for policy:$policy mark for WAN:$id All WANs: $wans; retval: $retval"
	while [ $retval -ne 0 ] ; do
		nft -f $TMPFILE
		retval=$?
		logMessage "nft -f failed during jump_policy for policy:$policy mark for WAN:$id All WANs: $wans; retval: $retval, trying again..."
	done
	rm $TMPFILE
}

# balance_policy is used to insert rules for balance policy types
# $1 - the policy
# $2 - the wans associated with this policy
# $3 - the total weight of all wans in the policy
# #4 - the generated balance string used in the vmap decision
balance_policy()
{
	policy=$1
	wans=$2
	total_weight=$3
	balance_string=$4

	TMPFILE=`mktemp -t $policy-changeset.XXXXXX`

	for wan in $wans ; do
		echo flush set ip wan-routing wan-$wan-table >> $TMPFILE
		echo flush set ip6 wan-routing wan-$wan-table >> $TMPFILE
	done

	echo flush chain ip wan-routing route-to-$policy >> $TMPFILE
	echo flush set ip wan-routing $policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy set update ip saddr . ip daddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy set update ip daddr . ip saddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy jump update-rule-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy dict sessions ct id wan_policy long_string set $policy >> $TMPFILE
	echo add ip wan-routing route-to-$policy numgen random mod $total_weight vmap { $balance_string } >> $TMPFILE

	echo flush chain ip6 wan-routing route-to-$policy >> $TMPFILE
	echo flush set ip6 wan-routing $policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy set update ip6 saddr . ip6 daddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy set update ip6 daddr . ip6 saddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy jump update-rule-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy dict sessions ct id wan_policy long_string set $policy >> $TMPFILE
	echo add ip6 wan-routing route-to-$policy numgen random mod $total_weight vmap { $balance_string } >> $TMPFILE

	nft -f $TMPFILE
	retval=$?
	logMessage "running balance policy:$policy All Wans:$wans total_weight:$total_weight balance string:$balance_string Retval: $retval"
	while [ $retval -ne 0 ] ; do
		nft -f $TMPFILE
		retval=$?
		logMessage "nft -f failed while running balance policy:$policy All Wans:$wans total_weight:$total_weight balance string:$balance_string Retval: $retval, trying again..."
	done
	rm $TMPFILE
}

# specific_wan is used to send traffic to a specific wan policy
# $1 - the associated policy and policy id
# $2 - the interface id
specific_wan()
{
	policy=$1
	id=$2

	policy_dir="/tmp/wan_status/$policy"
	mkdir -p $policy_dir

	status="init"

	if wan_is_up $policy $id "ipv4"; then
		result="up"
	else
		result="down"
	fi

	if [ ! $result = $status ] ; then
		status=$result
		if [ $status = "up" ] ; then
			jump_policy $policy $id "$id"
		else
			disable_policy $policy "$id"
		fi
	fi

}

# best_of is used to insert route rules for wans that fall into a specific best_of metric
# $1 - the policy name
# $2 - the stat name to test with
# $3 - the metric name to test with
# $4 - the operator to test with
best_of()
{
	policy=$1
	stat_name=$2
	metric_name=$3
	operator=$4

	policy_dir="/tmp/wan_status/$policy"
	status_file="$policy_dir/status"
	mkdir -p $policy_dir

	status="init"
	current_best_wan=-1
	best_wan=-1
	best_stat=-1

	## If the status file already exists, lets see what the previous status was
	if [ -f $status_file ] ; then
		. $status_file
	fi

	logMessage "best_of: $policy and $status_file current status: $status, best_wan: $best_wan, best_stat: $best_stat"

	wans=""
	policy_wans=""

	determinePolicyWans $policy_dir $wans $policy_wans

	logMessage "best_of: wans: $wans policy_wans: $policy_wans"

	for wan in $wans ; do
		stat=$(get_stat $wan $stat_name $metric_name)

		logMessage "best_of: comparing best_wan ($best_wan stat: $best_stat) with wan: $wan, stat $stat $stat_name $metric_name"

		# Important assumption here!!! 
		# VPNs and some other interfaces sometimes report a latency of 0
		# If this happens, we should continue and ignore this particular interface during best_of calculations
		if [ $stat_name = "latency" ] ; then
			if [ "$stat" = 0 ] || [ "$stat" = -1 ] ; then
				continue
			fi
		fi

		if [ $best_wan -eq -1 ] ; then
			best_wan=$wan
			best_stat=$stat
		else
			case $operator in
				le)
					if [ $stat -le $best_stat ] ; then
						best_wan=$wan
						best_stat=$stat
					fi
					;;
				lt)
					if [ $stat -lt $best_stat ] ; then
						best_wan=$wan
						best_stat=$stat
					fi
					;;
				ge)
					if [ $stat -ge $best_stat ] ; then
						best_wan=$wan
						best_stat=$stat
					fi
					;;
				gt)
					if [ $stat -gt $best_stat ] ; then
						best_wan=$wan
						best_stat=$stat
					fi
					;;
			esac
		fi
	done

	if [ $best_wan -eq -1 ] ; then
		result="down"
	else
		result="up"
	fi

	logMessage "best_of: all_wans:$wans current_best_wan:$current_best_wan best_wan:$best_wan result:$result status:$status"
	if [ ! $result = $status ] || [ ! $current_best_wan -eq $best_wan ] ; then
		if [ $result = "up" ] ; then
			logMessage "best_of: Switching best WAN: current_best_wan: $current_best_wan best_wan: $best_wan result: $result status: $status"
			jump_policy $policy $best_wan "$policy_wans"
			current_best_wan=$best_wan
		else
			logMessage "best_of: Disabling policy:$policy with WANs:$policy_wans"	
			disable_policy $policy "$policy_wans"
		fi
	fi
	status=$result
	echo "status=$status" > $status_file
	echo "current_best_wan=$current_best_wan" >> $status_file
	
}

# balance is used to balance a group of wans using a specific balancing algorithm
# $1 - the policy associated
# $2 - the balance algorithm to use (ie: LATENCY, WEIGHTED, AVAILABLE_BANDWIDTH)
balance()
{

	policy=$1
	algorithm=$2

	policy_dir="/tmp/wan_status/$policy"
	mkdir -p $policy_dir
	status_file="$policy_dir/status"

	status="init"
	balance_string=""

	## If the policy_status already exists, lets see what the previous status was
	if [ -f $status_file ] ; then
		. $status_file
	fi

	logMessage "balance: $policy and $status_file current status is $status"

	wans=""
	policy_wans=""
	total_weight=0
	new_balance_string=""

	determinePolicyWans $policy_dir $wans $policy_wans

	logMessage "balance: wans: $wans policy_wans: $policy_wans"

	total_latency=0
	if [ $algorithm = "LATENCY" ] ; then
		for wan in $wans ; do
			latency=$(get_stat $wan "latency" "1_minute")
			total_latency=$((total_latency + $latency))
		done
	fi
	for wan in $wans ; do
		if [ $algorithm = "WEIGHTED" ] ; then
			weight=$(get_static_weight $policy $wan)
		elif [ $algorithm = "LATENCY" ] ; then
			weight=$(get_stat $wan "latency" "1_minute")
			weight=$(($total_latency - $weight))
			if [ $weight -eq 0 ] ; then
				weight=100
			fi
		elif [ $algorithm = "AVAILABLE_BANDWIDTH" ] ; then
			weight=$(get_stat $wan "available_bandwidth" "1_minute")
		elif [ $algorithm = "BANDWIDTH" ] ; then
			weight=$(get_wan_bandwidth $wan)
		fi

		if [ $weight -eq 0 ] ; then
			continue
		fi

		if [ $total_weight -ne 0 ] ; then
			new_balance_string="$new_balance_string, "
		fi

		range_end=$(($weight + $total_weight - 1))
		if [ $total_weight -eq $range_end ] ; then
			new_balance_string="$new_balance_string$total_weight : jump mark-for-wan-$wan"
		else
			new_balance_string="$new_balance_string$total_weight-$range_end : jump mark-for-wan-$wan"
		fi
		total_weight=$((total_weight + $weight))
	done

	if [ "$new_balance_string" = "" ] ; then
		result="down"
		if [ ! $status = "down" ] ; then
			disable_policy $policy "$policy_wans"
		fi
	else
		result="up"
		if [ ! $status = "up" ] || [ ! "$new_balance_string" = "$balance_string" ] ; then
			balance_policy $policy "$policy_wans" $total_weight "$new_balance_string"
			balance_string="$new_balance_string"
		fi
	fi
	status=$result
	echo "status=$status" > $status_file
	echo "balance_string=$balance_string" >> $status_file
}

# attribute is used to insert policy rules associated to a wan with specific attributes
# $1 - the policy 
# $2 - the interface id
# $3 - the interface name
# $4 - the attribute to test for
attribute()
{
	policy=$1
	id=$2
	interface=$3
	attribute=$4

	result_dir="/tmp/wan_status/$policy/wan-$id"
	if [ $attribute = "NAME" ] ; then
		contains=$5
		result=$6
		result_file="$result_dir/${attribute}_${contains}"
	else
		result=$5
		result_file="$result_dir/$attribute"
	fi
	mkdir -p $result_dir

	echo $result > $result_file
}

# metric is used to insert policy rules that check specific metrics against interfaces
# $1 - the policy
# $2 - the interface id
# $3 - the interface name
# $4 - the stat name to use in the metric calculation
# $5 - the metric name to use in the metric calculation
# $6 - the operator to use in the metric calculation
# $7 - the metric value to test against in the metric calculation
metric()
{
	policy=$1
	id=$2
	interface=$3
	stat_name=$4
	metric_name=$5
	operator=$6
	val=$7

	status="init"

	test=-1

	result_dir="/tmp/wan_status/$policy/wan-$id"
	result_file="$result_dir/${stat_name}_${metric_name}_${operator}_${val}"
	mkdir -p $result_dir
	
	## If the status file already exists, lets see what the previous status was
	if [ -f $result_file ] ; then
		status=$(head -n 1 $result_file)
	fi

	logMessage "$policy and $result_file current status is $status"

	test=$(get_stat $id $stat_name $metric_name)

	# Important assumption here!!!
	# VPNs and some other interfaces sometimes report a latency of 0
	# Setting the test results to -1 will allow the logic below to skip this interface during the WAN checks
	if [ $stat_name = "latency" ] && [ $test = 0] ; then
		test=-1
	fi

	result="down"
	if [ $test -ne -1 ] ; then
		case $operator in
			le)
				if [ $test -le $val ] ; then
					result="up"
				fi
				;;
			lt)
				if [ $test -lt $val ] ; then
					result="up"
				fi
				;;
			ge)
				if [ $test -ge $val ] ; then
					result="up"
				fi
				;;
			gt)
				if [ $test -gt $val ] ; then
					result="up"
				fi
				;;
		esac
	fi

	if [ ! $result = $status ] ; then
		echo $result > $result_file
		status=$result
	fi
}

# up is used to determine which interfaces should be used in a policy calculation
# based on connectivity
# $1 - policy to store the interface status with
# $2 - interfaceId to store the status files in
# $3 - the openwrt interface name 
# $4 - the ip family of the interface
up()
{
	policy=$1
	interfaceId=$2
	interface=$3
	family=$4

	result_dir="/tmp/wan_status/$policy/wan-$interfaceId"
	result_file="$result_dir/$family"

	status="init"

	mkdir -p $result_dir

	## If the result_file already exists, lets see what the previous status was
	if [ -f $result_file ] ; then
		status=$(head -n 1 $result_file)
	fi

	logMessage "$interface and $result_file current status is $status"

	network_flush_cache
	offline=$(is_offline $interfaceId $family)
	if network_is_up $interface  && [ "$offline" = "false" ]; then
		logMessage "$interface is up"
		#echo up > $result_file
		result="up"
	else
		#echo down > $result_file
		logMessage "$interface is down"
		result="down"
	fi

	if [ ! $result = $status ] ; then
		logMessage "Updating $interface file with new status result:$result..."
		echo $result > $result_file
		status=$result
	fi
}

# test is used to insert policy rules for specific connectivity testing types or methods on the wan
# $1 - the policy to use
# $2 - the interface id for the policy
# $3 - the interface name
# $4 - the criteria type to use (ping, http, arp, dns)
# $5 - the interval of when to run the tests
# $6 - the timeout of when to fail the test
# $7 - the failure threshold of when to fail the tests
# $8 - the host to run the connectivity tests against
test()
{
	policy=$1
	interfaceId=$2
	interface=$3
	criteria=$4
	interval=$5
	timeout=$6
	threshold=$7
	host=$8

	local device ip_address dns_server gw

	result0=1
	result1=1
	result2=1
	result3=1
	result4=1
	result5=1
	result6=1
	result7=1
	result8=1
	result9=1

	status="init"

	result_dir="/tmp/wan_status/$policy/wan-$interfaceId"
	result_file="$result_dir/${criteria}_${host}_${interval}_${timeout}_${threshold}"

	mkdir -p $result_dir

	## If the result_file already exists, lets see what the previous status was
	if [ -f $result_file ] ; then
		status=$(head -n 1 $result_file)
	fi

	logMessage "$policy and $result_file current status is $status"

	for i in $(seq 0 9) ; do
		logMessage "Flushing cache and looking for interface: $interface..."
		network_flush_cache
		if network_is_up $interface  && [ "$offline" = "false" ]; then

			network_get_device device $interface
			network_get_ipaddr ip_address $interface
			network_get_dnsserver dns_server $interface
			network_get_gateway gw $interface

			case $criteria in
				ping)
					ping -I $device -w $timeout -c 1 $host > /dev/null && let result"$i"=1 || let result"$i"=0
					;;
				arp)
					arping -s $ip_address -I $device -c 1 $gw > /dev/null && let result"$i"=1 || let result"$i"=0
					;;
				dns)
					dig -b $ip_address +tries=3 +timeout=$timeout $dns_server $host > /dev/null && let result"$i"=1 || let result"$i"=0
					;;
				http)
					wget --no-check-certificate --bind-address=$ip_address --header="Wan-Failover-Flag: true" --tries=3 -O /dev/null $host 2> /dev/null && let result"$i"=1 || let result"$i"=0
					;;
				*)
					echo "Unknown test $criteria"
					let result"$i"=0
					;;
			esac

			count=0
			for i in $(seq 0 9) ; do
				eval "temp=\"\$result$i\""
				if [ $temp -eq 0 ] ; then
					let count++
				fi
			done
			if [ $count -ge $threshold ] ; then
				result="down"
			else
				result="up"
			fi
		fi

		if [ ! $result = $status ] ; then
			echo $result > $result_file
			status=$result
		fi

		logMessage "WAN-Manager test interval running"
	done
}

# wan-manager main entry point, check for wan-routing tables before continuing
check_for_table ip wan-routing
check_for_table ip6 wan-routing

# create term handler and run the handle_term callback
trap 'handle_term' TERM INT

# cleanup old wan_status files
rm -rf /tmp/wan_status/*

# Wait for stats.json to change, and then run every policy once (vs having each policy wait for change every time)
while [ 1 ] ; do
	wait_for_change /tmp/stats.json
	. /etc/config/wan_manager
done

for i in `pgrep -P $$ `
do
	wait $i
done
